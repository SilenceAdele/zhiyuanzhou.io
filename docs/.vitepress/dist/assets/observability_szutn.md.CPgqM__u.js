import{_ as t,c as a,o as l,aM as i}from"./chunks/framework.DTUrUyLr.js";const u=JSON.parse('{"title":"prometheus tsdb - Head Block","description":"","frontmatter":{"date":"2025-11-14T00:07:51.000Z","title":"prometheus tsdb - Head Block","categories":["云原生可观测"],"tags":["prometheus","tsdb"],"coverImg":"https://image.zhiyuanzhou.online/defalutPostBgi.jpg","permalink":"/observability/szutn"},"headers":[],"relativePath":"observability/szutn.md","filePath":"02.云原生可观测/prometheus/01.tsdb/01.prometheus tsdb - Head Block.md","lastUpdated":1763686593000}'),o={name:"observability/szutn.md"};function h(s,e,d,r,n,p){return l(),a("div",null,[...e[0]||(e[0]=[i('<h1 id="prometheus-tsdb-head-block" tabindex="-1">prometheus tsdb - Head Block <a class="header-anchor" href="#prometheus-tsdb-head-block" aria-label="Permalink to &quot;prometheus tsdb - Head Block&quot;">​</a></h1><h2 id="一、概述" tabindex="-1">一、概述 <a class="header-anchor" href="#一、概述" aria-label="Permalink to &quot;一、概述&quot;">​</a></h2><p>prometheus v2.0引入了tsdb，以下是tsdb的全局模型介绍：</p><p><img src="https://cdn.jsdelivr.net/gh/SilenceAdele/zhiyuanzhou.io@master/docs/02.%E4%BA%91%E5%8E%9F%E7%94%9F%E5%8F%AF%E8%A7%82%E6%B5%8B/prometheus/01.tsdb/image/01.prometheustsdb-HeadBlock/1763051529947.png" alt="1763051529947" width="1000" height="200" loading="lazy"></p><hr><h3 id="🧠-内存部分-head-block" tabindex="-1">🧠 内存部分：Head Block <a class="header-anchor" href="#🧠-内存部分-head-block" aria-label="Permalink to &quot;🧠 内存部分：Head Block&quot;">​</a></h3><ul><li>Head block 是数据库中的内存部分，用于存储最新写入的数据。</li><li>每个新写入的样本（粉色框），首先会进入 Head block（即在内存中暂存）。</li><li>这是数据进入系统的第一站。</li></ul><hr><h3 id="🧾-wal-write-ahead-log" tabindex="-1">🧾 WAL（Write-Ahead Log） <a class="header-anchor" href="#🧾-wal-write-ahead-log" aria-label="Permalink to &quot;🧾 WAL（Write-Ahead Log）&quot;">​</a></h3><ul><li>WAL 用于持久化写入日志，确保即使服务崩溃也能恢复数据。</li><li>每个样本在写入内存的同时也会写入 WAL。</li><li>WAL 的存在让写入操作具备“先写日志，再更新内存”的安全性。</li></ul><hr><h3 id="📦-磁盘部分-灰色块和蓝色块" tabindex="-1">📦 磁盘部分：灰色块和蓝色块 <a class="header-anchor" href="#📦-磁盘部分-灰色块和蓝色块" aria-label="Permalink to &quot;📦 磁盘部分：灰色块和蓝色块&quot;">​</a></h3><ul><li>内存中的数据在一段时间后会被</li></ul><p>刷新（flush）到磁盘，形成灰色的持久化块（immutable blocks）。</p><ul><li>刷新过程中会先生成</li></ul><p>Memory-Mapped Chunks（蓝色块），即内存映射的中间状态。</p><hr><h3 id="🔁-块的生命周期管理" tabindex="-1">🔁 块的生命周期管理 <a class="header-anchor" href="#🔁-块的生命周期管理" aria-label="Permalink to &quot;🔁 块的生命周期管理&quot;">​</a></h3><ul><li>当蓝色块或内存块变“老”时，会被进一步刷新为磁盘上的持久块。</li><li>这些磁盘块是不可变的（immutable），不会再被更改。</li><li>多个旧块会被合并（merge），优化存储结构。</li><li>最终，当这些块超过设定的保留期（retention period），就会被自动删除。</li></ul><hr><h3 id="✅-总结流程" tabindex="-1">✅ 总结流程 <a class="header-anchor" href="#✅-总结流程" aria-label="Permalink to &quot;✅ 总结流程&quot;">​</a></h3><ol><li>样本准备写入 → 内存 Head block</li><li>先写入 WAL 日志，保证持久性</li><li>再写入Head block</li><li>一段时间后，flush 为 memory-mapped chunks（蓝色）</li><li>再转化为磁盘持久块（灰色）</li><li>多个块合并压缩</li><li>到期后删除</li></ol><h2 id="二、head-block-样本寿命" tabindex="-1">二、Head block 样本寿命 <a class="header-anchor" href="#二、head-block-样本寿命" aria-label="Permalink to &quot;二、Head block 样本寿命&quot;">​</a></h2><p>以单个时间序列为例，适用于所有序列。</p><p><img src="https://cdn.jsdelivr.net/gh/SilenceAdele/zhiyuanzhou.io@master/docs/02.%E4%BA%91%E5%8E%9F%E7%94%9F%E5%8F%AF%E8%A7%82%E6%B5%8B/prometheus/01.tsdb/image/01.prometheustsdb-HeadBlock/1763051562226.png" alt="1763051562226" width="1000" height="200" loading="lazy"></p><p>样本存储在称为“chunk”的压缩单元中。样本传入时，会被提取到“active chunk”（红色块）中。这是唯一可以主动写入数据的单元。</p><p>在将样本提交到chunk中时，我们还会将其记录在磁盘（棕色块）上的预写日志（Write-Ahead-Log ，简称WAL) 中，以实现持久性（这意味着即使机器突然崩溃，我们也可以从中恢复内存中的数据）。</p><p><img src="https://cdn.jsdelivr.net/gh/SilenceAdele/zhiyuanzhou.io@master/docs/02.%E4%BA%91%E5%8E%9F%E7%94%9F%E5%8F%AF%E8%A7%82%E6%B5%8B/prometheus/01.tsdb/image/01.prometheustsdb-HeadBlock/1763051674580.png" alt="1763051674580" width="1000" height="200" loading="lazy"></p><p>一旦一个块（chunk）填满了 120 个样本，或者跨越了 chunk/block 范围（这里我们称之为 chunkRange，默认是 2 小时），就会切割出一个新的块，而旧的块就被认为是“已满”的。</p><p>在这篇博客中，我们假设抓取间隔（scrape interval）是 15 秒，因此 120 个样本（一个完整的块）大约会覆盖 30 分钟。</p><p>带有数字 1 的黄色块表示刚刚填满的完整块，而红色的块表示新创建的块。</p><p><img src="https://cdn.jsdelivr.net/gh/SilenceAdele/zhiyuanzhou.io@master/docs/02.%E4%BA%91%E5%8E%9F%E7%94%9F%E5%8F%AF%E8%A7%82%E6%B5%8B/prometheus/01.tsdb/image/01.prometheustsdb-HeadBlock/1763051734225.png" alt="1763051734225" width="1000" height="200" loading="lazy"></p><p>从 Prometheus v2.19.0 开始，我们不再把所有的块（chunk）都存放在内存中。</p><p>一旦切割出一个新块，已满的块就会被刷新到磁盘上，并通过内存映射（memory-mapping）的方式从磁盘加载，同时在内存中只保存一个引用。</p><p>借助内存映射，我们在需要时可以通过这个引用，把块动态地加载到内存中；这是操作系统提供的一种功能。</p><p><img src="https://cdn.jsdelivr.net/gh/SilenceAdele/zhiyuanzhou.io@master/docs/02.%E4%BA%91%E5%8E%9F%E7%94%9F%E5%8F%AF%E8%A7%82%E6%B5%8B/prometheus/01.tsdb/image/01.prometheustsdb-HeadBlock/1763051755736.png" alt="1763051755736" width="1000" height="200" loading="lazy"></p><p>同样地，随着新的样本不断到来，就会不断切割出新的块（chunk）。</p><p><img src="https://cdn.jsdelivr.net/gh/SilenceAdele/zhiyuanzhou.io@master/docs/02.%E4%BA%91%E5%8E%9F%E7%94%9F%E5%8F%AF%E8%A7%82%E6%B5%8B/prometheus/01.tsdb/image/01.prometheustsdb-HeadBlock/1763051770953.png" alt="1763051770953" width="1000" height="200" loading="lazy"></p><p>它们会被刷新到磁盘上，并通过内存映射的方式进行加载。</p><p><img src="https://cdn.jsdelivr.net/gh/SilenceAdele/zhiyuanzhou.io@master/docs/02.%E4%BA%91%E5%8E%9F%E7%94%9F%E5%8F%AF%E8%A7%82%E6%B5%8B/prometheus/01.tsdb/image/01.prometheustsdb-HeadBlock/1763051785870.png" alt="1763051785870" width="1000" height="200" loading="lazy"></p><p>一段时间后，Head 块会像上图那样。假设红色的块已经快要填满，那么此时 Head 中就有 3 小时的数据（6 个块，每个块跨度为 30 分钟）。这相当于 <strong>chunkRange × 3/2</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/SilenceAdele/zhiyuanzhou.io@master/docs/02.%E4%BA%91%E5%8E%9F%E7%94%9F%E5%8F%AF%E8%A7%82%E6%B5%8B/prometheus/01.tsdb/image/01.prometheustsdb-HeadBlock/1763051800905.png" alt="1763051800905" width="1000" height="200" loading="lazy"></p><p><img src="https://cdn.jsdelivr.net/gh/SilenceAdele/zhiyuanzhou.io@master/docs/02.%E4%BA%91%E5%8E%9F%E7%94%9F%E5%8F%AF%E8%A7%82%E6%B5%8B/prometheus/01.tsdb/image/01.prometheustsdb-HeadBlock/1763051811858.png" alt="1763051811858" width="1000" height="200" loading="lazy">当 Head 中的数据跨度达到 <strong>chunkRange × 3/2</strong> 时，最早的一个 chunkRange 的数据（这里是 2 小时）会被压缩（compacted）成一个持久化块（persistent block）。如果你注意到上文，这个时候 WAL（预写日志）会被截断（truncate），并创建一个“检查点”（checkpoint）（图中未展示）。我会在后续的博客中详细介绍 <strong>checkpoint、WAL 截断、压缩、持久化块以及它的索引</strong>。</p><p>这种数据的摄取（ingestion）、内存映射、压缩形成持久化块的循环会不断进行。而这正是 Head 块 的基本功能。</p><p><strong>参考文献：</strong></p><p><a href="https://ganeshvernekar.com/blog/prometheus-tsdb-the-head-block/" target="_blank" rel="noreferrer">https://ganeshvernekar.com/blog/prometheus-tsdb-the-head-block/</a></p>',46)])])}const m=t(o,[["render",h]]);export{u as __pageData,m as default};
